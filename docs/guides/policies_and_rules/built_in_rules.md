# The Built-in Rules

English | [简体中文](built_in_rules.zh_CN.md)

**vArmor** supports defining [VarmorPolicy](../../getting_started/usage_instructions.md#varmorpolicy) or [VarmorClusterPolicy](../../getting_started/usage_instructions.md#varmorclusterpolicy) objects using built-in rules in **EnhanceProtect** mode. The currently supported built-in rules and categories are shown in the following table. You can also try using the [policy advisor](../policy_advisor.md) to generate a policy template with built-in rules.

Note:<br />- The built-in rules supported by different enforcers are still under development.<br />- There are some limitations in the rules and syntax supported by different enforcers. For example, the AppArmor enforcer does not support fine-grained network access control, and BPF does not support access control for specified executables.<br />

| Category | Subcategory | Rule Name & ID | Applicable Container | Description | Principle & Impact | Supported Enforcer |
|----------|-------------|----------------|----------------------|-------------|--------------------|--------------------|
|**Hardening**|Securing Privileged Containers|Prohibit modifying procfs' core_pattern <br /><br />`disallow-write-core-pattern`|Privileged|Attackers may attempt container escape by modifying the procfs core_pattern in a **privileged container** or, in a container (**w/ CAP_SYS_ADMIN**), unmounting specific mount points and then modifying the procfs core_pattern to execute a container escape.|Disallow writing to the procfs' core_pattern file.|AppArmor<br />BPF
|         |                      |Prohibit mounting securityfs<br /><br />`disallow-mount-securityfs`|Privileged|Attackers may attempt container escape in containers (**w/ CAP_SYS_ADMIN**) by mounting securityfs with read-write permissions and subsequently modifying it.|Disallow mounting of new security file systems.|AppArmor<br />BPF
|         |                      |Prohibit remounting procfs<br /><br />`disallow-mount-procfs`|Privileged|Attackers may attempt container escape in containers (**w/ CAP_SYS_ADMIN**) by remounting procfs with read-write permissions and subsequently modifying the core_pattern, among other things.|1. Disallow mounting of new proc file systems.<br /><br />2. Prohibit using bind, rbind, move, remount options to remount `/proc**`.<br /><br />3. When using BPF enforcer, it also prevents unmounting `/proc**`.|AppArmor<br />BPF
|         |                      |Prohibit modifying cgroupfs' release_agent<br /><br />`disallow-write-release-agent`|Privileged|Attackers may attempt container escape within **privileged container** by directly modifying the cgroupfs release_agent.|Disallow writing to the cgroupfs' release_agent file.|AppArmor<br />BPF
|         |                      |Prohibit remounting cgroupfs<br /><br />`disallow-mount-cgroupfs`|Privileged|Attackers may attempt to escape from containers (**w/ CAP_SYS_ADMIN**) by remounting cgroupfs with read-write permissions. Subsequently, they can modify release_agent and device access permissions, among other things.|1. Disallow mounting new cgroup file systems.<br /><br />2. Prohibit using bind, rbind, move, remount options to remount `/sys/fs/cgroup**`.<br /><br />3. Prohibit using rbind option to remount `/sys**`. <br /><br />4. When using BPF enforcer, it also prevents unmounting `/sys**`.|AppArmor<br />BPF
|         |                      |Prohibit debugging of disk devices<br /><br />`disallow-debug-disk-device`|Privileged|Attackers may attempt to read and write host machine files by debugging host machine disk devices within a **privileged container**.<br /><br />It is recommended to use this rule in conjunction with `disable-cap-mknod` to prevent attackers from bypassing the rule with mknod.|Dynamically acquire host disk devices and restrict container access them with read-write permissions.|AppArmor<br />BPF
|         |                      |Prohibit mounting of host's disk devices<br /><br />`disallow-mount-disk-device`|Privileged|Attackers may attempt to mount host machine disk devices within a **privileged container**, thereby gaining read-write access to host machine files.<br /><br />It is recommended to use this rule in conjunction with `disable-cap-mknod` to prevent attackers from bypassing the rule with mknod.|Dynamically acquire host machine disk device files and prevent mounting within containers.|AppArmor<br />BPF
|         |                      |Disable the mount system call<br /><br />`disallow-mount`|Privileged|[MOUNT(2)](https://man7.org/linux/man-pages/man2/mount.2.html) is often used for privilege escalation, container escapes, and other attacks. Most microservices applications do not require mount operations. Therefore, it is recommended to use this rule to restrict container processes from using the `mount()` system call.<br /><br />Note: The mount system call will be disabled by default if the `spec.policy.privileged` field is false.|Disable the mount system call.|AppArmor<br />BPF
|         |                      |Disable the umount system call<br /><br />`disallow-umount`|ALL|[UMOUNT(2)](https://man7.org/linux/man-pages/man2/umount.2.html) can be used to remove the attachment of topmost mount points(such as maskedPaths), leading to privilege escalation and information disclosure. Most microservices applications do not require umount operations. Therefore, it is recommended to use this rule to restrict container processes from using the `umount()` system call.|Disable the umount system call.|AppArmor<br />BPF
|         |                      |Prohibit loading kernel modules<br /><br />`disallow-insmod`|Privileged|Attackers may attempt to inject code into the kernel within a container (**w/ CAP_SYS_MODULE**) by executing kernel module loading command.|Disable CAP_SYS_MODULE|AppArmor<br />BPF
|         |                      |Prohibit loading eBPF programs, except for those of the BPF_PROG_TYPE_SOCKET_FILTER and BPF_PROG_TYPE_CGROUP_SKB types.<br /><br />`disallow-load-bpf-prog`, `disallow-load-ebpf`|ALL|Attackers may load eBPF programs within a container (**w/ CAP_SYS_ADMIN, CAP_BPF**) to theft data or create rootkit.<br /><br />Before Linux 5.8, loading eBPF programs, except for those of the BPF_PROG_TYPE_SOCKET_FILTER and BPF_PROG_TYPE_CGROUP_SKB types, needs CAP_SYS_ADMIN. Since Linux 5.8, loading eBPF programs, except for those types, needs CAP_SYS_ADMIN or CAP_BPF. And some types of eBPF programs also require CAP_NET_ADMIN or CAP_PERFMON.<br /><br />It is recommended to use the `disallow-load-all-bpf-prog` rule to prohibit loading any types of eBPF programs to reduce the attack surface of kernel.|Disable CAP_SYS_ADMIN & CAP_BPF|AppArmor<br />BPF
|         |                      |Prohibit accessing process's root directory<br /><br />`disallow-access-procfs-root`|ALL|This policy prohibits processes within containers from accessing the root directory of the process filesystem (i.e., /proc/[PID]/root), preventing attackers from exploiting shared PID namespaces to launch attacks.<br /><br />Attackers may attempt to access the process filesystem outside the container by reading and writing to /proc/*/root in environments where the PID namespace is shared with the host or other containers. This could lead to information disclosure, privilege escalation, lateral movement, and other attacks.|Disable PTRACE_MODE_READ permission |AppArmor<br />BPF
|         |                      |Prohibit accessing kernel exported symbol<br /><br />`disallow-access-kallsyms`|ALL|Attackers may attempt to leak the base address of kernel modules from containers (**w/ CAP_SYSLOG**) by reading the kernel's exported symbol definitions file. This assists attackers in bypassing KASLR protection to exploit kernel vulnerabilities more easily.|Disallow reading /proc/kallsyms file|AppArmor<br />BPF
|         |Disable Capabilities|Disable all capabilities<br /><br />`disable-cap-all`|ALL|Disable all capabilities|-|AppArmor<br />BPF
|         |                    |Disable all capabilities except for NET_BIND_SERVICE<br /><br />`disable-cap-all-except-net-bind-service`|ALL|Disable all capabilities except for NET_BIND_SERVICE.<br /><br />This rule complies with the [*Restricted Policy*](https://kubernetes.io/concepts/security/pod-security-standards/#restricted) of the Pod Security Standards.|-|AppArmor<br />BPF
|         |                    |Disable privileged capabilities<br /><br />`disable-cap-privileged`|ALL|Disable all privileged capabilities (those that can directly lead to escapes or affect host availability). Only allow the [default capabilities](https://github.com/containerd/containerd/blob/release/1.7/oci/spec.go#L115).<br /><br />This rule complies with the [*Baseline Policy*](https://kubernetes.io/concepts/security/pod-security-standards/#restricted) of the Pod Security Standards, except for the net_raw capability.|-|AppArmor<br />BPF
|         |                    |Disable specified capability<br /><br />`disable-cap-XXXX`|ALL|Disable any specified capabilities, replacing XXXX with the values from 'capabilities(7),' for example, disable-cap-net-raw.|-|AppArmor<br />BPF
|         |Blocking Exploit Vectors|Prohibit abusing user namespaces<br /><br />`disallow-abuse-user-ns`|ALL|User namespaces can be used to enhance container isolation. However, it also increases the kernel's attack surface, making certain kernel vulnerabilities easier to exploit. Attackers can use a container to create a user namespace, gaining full privileges and thereby expanding the kernel's attack surface<br /><br />Disallowing container processes from abusing CAP_SYS_ADMIN privileges via user namespaces can reduce the kernel's attack surface and block certain exploitation paths for kernel vulnerabilities.<br /><br />This rule can be used to harden containers on systems where kernel.unprivileged_userns_clone=0 or user.max_user_namespaces=0 is not set.| Disable CAP_SYS_ADMIN |AppArmor<br />BPF
|         |                        |Prohibit creating user namespace<br /><br />`disallow-create-user-ns`|ALL|User namespaces can be used to enhance container isolation. However, it also increases the kernel's attack surface, making certain kernel vulnerabilities easier to exploit. Attackers can use a container to create a user namespace, gaining full privileges and thereby expanding the kernel's attack surface<br /><br />Disallowing container processes from creating new user namespaces can reduce the kernel's attack surface and block certain exploitation paths for kernel vulnerabilities.<br /><br />This rule can be used to harden containers on systems where kernel.unprivileged_userns_clone=0 or user.max_user_namespaces=0 is not set.| Disallow creating user namespace. |Seccomp
|         |                        |Prohibit loading any types of eBPF programs<br /><br />`disallow-load-all-bpf-prog`|ALL|Attackers can load BPF_PROG_TYPE_SOCKET_FILTER or BPF_PROG_TYPE_CGROUP_SKB types of extended BPF (eBPF) programs without privileged permission. So they may use these types of eBPF programs to sniff network data package, or exploit vulnerabilities of the BPF verifier or JIT engine to achieve container escape.<br /><br />This rule can be used to harden containers on systems where kernel.unprivileged_bpf_disabled=0.|Disallow loading any types of eBPF programs via bpf syscall with BPF_PROG_LOAD parameters.|Seccomp
|         |                        |Disallow loading any types of eBPF programs via bpf syscall with BPF_PROG_LOAD parameters.<br /><br />`disallow-load-bpf-via-setsockopt`|ALL|Attackers can load classic BPF (cBPF) programs via the setsockopt syscall without privileged permission. They may use this way to perform some BPF JIT spraying.<br /><br />This can be a powerful means to exploit kernel vulnerabilities. Because this exploit vector does not rely on any capability and is outside the control of the kernel.unprivileged_bpf_disabled sysctl.|Disallow loading classic BPF programs via setsockopt syscall with SO_ATTACH_FILTER or SO_ATTACH_REUSEPORT_CBPF parameter.|Seccomp
|**Attack Protection**|Mitigating Information Leakage|Mitigating ServiceAccount token leakage.<br /><br />`mitigate-sa-leak`|ALL|This rule prohibits container processes from reading sensitive Service Account-related information, including tokens, namespaces, and CA certificates. It helps prevent security risks arising from the leakage of Default ServiceAccount or misconfigured ServiceAccount. In the event that attackers gain access to a container through an RCE vulnerability, they often seek to further infiltrate by leaking ServiceAccount information.<br /><br />In most user scenarios, there is no need for Pods to communicate with the API Server using ServiceAccounts. However, by default, Kubernetes still sets up default ServiceAccounts for Pods that do not require communication with the API Server.|Disallow reading ServiceAccount-related files.|AppArmor<br />BPF
|                 |             |Mitigating host disk device number leakage<br /><br />`mitigate-disk-device-number-leak`|ALL|Attackers may attempt to obtain host disk device numbers for subsequent container escape by reading the container process's mount information.|Disallow reading /proc/[PID]/mountinfo and /proc/partitions files|AppArmor<br />BPF
|                 |             |Mitigating container overlayfs path leakage<br /><br />`mitigate-overlayfs-leak`|ALL|Attackers may attempt to obtain the overlayfs path of the container's rootfs on the host by accessing the container process's mount information, which could be used for subsequent container escape.|Disallow reading /proc/mounts, /proc/[PID]/mounts, and /proc/[PID]/mountinfo files.<br /><br />This rule may impact some functionality of the 'mount' command or syscall within containers|AppArmor<br />BPF
|                 |             |Mitigating host IP leakage<br /><br />`mitigate-host-ip-leak`|ALL|After gaining access to a container through an RCE vulnerability, attackers often attempt further network penetration attacks. Therefore, restricting attackers from obtaining sensitive information such as host IP, MAC, and network segments through this vector can increase the difficulty and cost of their network penetration activities.|Disallow reading ARP address resolution tables (/proc/net/arp, /proc/[PID]/net/arp, etc.)|AppArmor<br />BPF
|                 |             |Disallow access to the metadata service<br /><br />`disallow-metadata-service`|ALL|This rule prohibits container processes from accessing the cloud server's Instance Metadata Service, including two reserved local addresses: 100.96.0.96 and 169.254.169.254.<br /><br />Attackers, upon gaining code execution privileges within a container, may attempt to access the cloud server's Metadata Service for information disclosure. In certain scenarios, attackers may obtain sensitive information, leading to privilege escalation and lateral movement.|Prohibit connections to Instance Metadata Services' IP addresses|BPF
|                 |Disable Sensitive Operations|Prohibit writing to the /etc directory<br /><br />`disable-write-etc`|ALL|Attackers may attempt privilege escalation by modifying sensitive files in the /etc directory, such as altering /etc/bash.bashrc for watering hole attacks, editing /etc/passwd and /etc/shadow to add users for persistence, or modifying nginx.conf or /etc/ssh/ssh_config for persistence.|Disallow writing to the /etc directory|AppArmor<br />BPF
|                 |              |Prohibit the execution of busybox command<br /><br />`disable-busybox`|ALL|Some application services are packaged using base images like busybox or Alpine. This also provides attackers with a lot of convenience, as they can use busybox to execute commands and assist in their attacks.|Prohibit the execution of busybox.<br /><br />If containerized services rely on busybox or related bash commands, enabling this policy may lead to runtime errors.|AppArmor<br />BPF
|                 |              |Prohibit the creation of Unix shells<br /><br />`disable-shell`|ALL|After gaining remote code execution privileges through an RCE vulnerability, attackers may use a reverse shell to gain arbitrary command execution capabilities within the container.<br /><br />This rule prohibits container processes from creating new Unix shells, thus defending against reverse shell.|Prohibit the creation of Unix shells<br /><br />Some base images may symlink sh to /bin/busybox. In this scenario, it's also necessary to prohibit the execution of busybox.|AppArmor<br />BPF
|                 |              |Prohibit the execution of wget command<br /><br />`disable-wget`|ALL|Attackers may use the wget command to download malicious programs for subsequent attacks, such as persistence, privilege escalation, network scanning, cryptocurrency mining, and more.<br /><br />This rule limits file downloads by prohibiting the execution of the wget command.|Prohibit the execution of wget<br /><br />Some base images may symlink wget to /bin/busybox. In this scenario, it's also necessary to prohibit the execution of busybox.|AppArmor<br />BPF
|                 |              |Prohibit the execution of curl command<br /><br />`disable-curl`|ALL|Attackers may use the curl command to initiate network access and download malicious programs from external sources for subsequent attacks, such as persistence, privilege escalation, network scanning, cryptocurrency mining, and more.<br /><br />This rule limits network access by prohibiting the execution of the curl command.|Prohibit the execution of curl command.|AppArmor<br />BPF
|                 |              |Prohibit the execution of chmod command<br /><br />`disable-chmod`|ALL|When attackers gain control over a container through vulnerabilities, they typically attempt to download additional attack code or tools into the container for further attacks, such as privilege escalation, lateral movement, cryptocurrency mining, and more. In this attack chain, attackers often use the chmod command to modify file permissions for execution.|Prohibit the execution of chmod command.<br /><br />Some base images may symlink wget to /bin/busybox. In this scenario, it's also necessary to prohibit the execution of busybox command.|AppArmor<br />BPF
|                 |              |Prohibit setting the execute/search bit of a file<br /><br />`disable-chmod-x-bit`|ALL|When attackers gain control over a container through vulnerabilities, they typically attempt to download additional attack code or tools into the container for further attacks, such as privilege escalation, lateral movement, cryptocurrency mining, and more. In this attack chain, attackers might use the chmod syscalls to modify file permissions for execution.|Prohibit setting the execute/search bit of a file with `chmod/fchmod/fchmodat/fchmodat2` syscalls|Seccomp
|                 |              |Prohibit setting the SUID/SGID bit of a file<br /><br />`disable-chmod-s-bit`|ALL|In some scenarios, attackers may attempt to invoke chmod syscalls to perform privilege elevation attacks by setting the file's s-bit (set-user-ID, set-group-ID).|Prohibit setting the set-user-ID/set-group-ID bit of a file with `chmod/fchmod/fchmodat/fchmodat2` syscalls|Seccomp
|                 |              |Prohibit the execution of su/sudo command<br /><br />`disable-su-sudo`|ALL|When processes within a container run as non-root users, attackers often need to escalate privileges to the root user for further attacks. The sudo/su commands are common local privilege escalation avenues.|Prohibit the execution of su/sudo command.<br /><br />Some base images may symlink su to /bin/busybox. In this scenario, it's also necessary to prohibit the execution of busybox command.|AppArmor<br />BPF
|                 |Others        |Prohibit all network access<br /><br />`disable-network`|ALL|When you want to prevent a container from accessing the network, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit accessing the network via inet4 addresses<br /><br />`disable-inet`, `disable-ipv4`|ALL|When you want to prevent a container from accessing the network via IPv4 addresses, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit accessing the network via inet6 addresses<br /><br />`disable-inet6`, `disable-ipv6`|ALL|When you want to prevent a container from accessing the network via IPv6 addresses, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit accessing the network via UDS addresses<br /><br />`disable-unix-domain-socket`|ALL|When you want to prevent a container from accessing the network via Unix Domain Socket addresses, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit the use of the ICMP protocol<br /><br />`disable-icmp`|ALL|When you want to prevent a container from using ICMP protocol, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit the use of the TCP protocol<br /><br />`disable-tcp`|ALL|When you want to prevent a container from using TCP protocol, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |              |Prohibit the use of the UDP protocol<br /><br />`disable-udp`|ALL|When you want to prevent a container from using UDP protocol, you can use this rule to disable it.|-|AppArmor<br />BPF
|                 |Restrict Specific Executable|-|ALL|This rule extends the use cases of 'Mitigating Information Leakage' and 'Disabling Sensitive Operations', it allows user to apply restrictions only to specific executable programs within containers.<br /><br />Restricting specified executable programs serves two purposes:<br />1). Preventing sandbox policies from affecting the execution of application services within containers.<br />2).Restricting specified executable programs within containers increases the cost and difficulty for attackers<br /><br />For example, this feature can be used to restrict programs like busybox, bash, sh, curl within containers, preventing attackers from using them to execute sensitive operations. Meanwhile, the application services is unaffected by sandbox policies and can continue to access ServiceAccount tokens and perform other tasks normally.<br /><br />*Note: Due to the implementation principles of BPF LSM, this feature cannot be **robustly** provided by the BPF enforcer.*|Enable sandbox restrictions for specified executable programs.|AppArmor
|**Vulnerability Mitigation**|-|Mitigate cgroups & lxcfs escape<br /><br />`cgroups-lxcfs-escape-mitigation`|ALL|If users mount the host's cgroupfs into a container or use lxcfs to provide a resource view for the container, there may be a risk of container escape in both scenarios. Attackers could manipulate cgroupfs from within the container to achieve container escape.<br /><br />This rule can also be used to defend against [CVE-2022-0492](https://unit42.paloaltonetworks.com/cve-2022-0492-cgroups/) vulnerability exploitation.|AppArmor Enforcer prevents writing to：<br />/\*\*/release_agent, <br />/\*\*/devices/device.allow,<br />/\*\*/devices/\*\*/device.allow, <br />/\*\*/devices/cgroup.procs,<br />/\*\*/devices/\*\*/cgroup.procs,<br />/\*\*/devices/task,<br />/\*\*/devices/\*\*/task,<br /><br />BPF Enforcer prevents writing to：<br />/\*\*/release_agent<br />/\*\*/devices.allow<br />/\*\*/cgroup.procs<br />/\*\*/devices/tasks<br />|AppArmor<br />BPF
|                            |-|Mitigate the ability to override runc to escape<br /><br />`runc-override-mitigation`|ALL|The rule is designed to mitigate vulnerabilities such as [CVE-2019-5736](https://github.com/advisories/GHSA-gxmr-w5mj-v8hh) that exploit container escape by tampering with the host machine's runc.|Disallow writing to `/**/runc` files|AppArmor<br />BPF
|                            |-|Mitigate the 'Dirty Pipe' exploit to escape<br /><br />`dirty-pipe-mitigation`|ALL|The rule is designed to defend against attacks exploiting the [CVE-2022-0847 (Dirty Pipe)](https://dirtypipe.cm4all.com/) vulnerability for container escape. You can use this rule to harden container, before upgrading or patching the kernel.<br /><br />Note: While this rule may cause issues in some software packages, blocking the syscall usually does not have an effect on legitimate applications, since use of this syscall is relatively rare.| Disallow calling splice syscall|Seccomp
|||THIS_IS_A_PLACEHOLDER_PLACEH|
